<!-- TOC -->

- [badKnowHow 論理設計のバッドノウハウ](#badKnowHow論理設計のバッドノウハウ)
  - [非スカラ値](#非スカラ値)
  - [ダブルミーニング](#ダブルミーニング)
  - [単一参照テーブル](#単一参照テーブル)
  - [テーブル分割](#テーブル分割)
  - [不適切なキー](#不適切なキー)
  - [ダブルマスタ](#ダブルマスタ)

<!-- /TOC -->

#### badKnowHow 論理設計のバッドノウハウ

- 戦略の失敗を戦術で取り返すことはできない
- ダメ設計が生まれる理由のほとんどは「何も考えていない」から

##### 非スカラ値（第一正規形未満）

- SQL の世界共通の標準規格が１９９９年に配列型を採用し、非スカラ値を含むテーブルを作ることができる。

```SQL
CREATE TABLE huyosha(
    shain_id varchar(4),
    shain_mei varchar(20),
    kodomo varchar(29)[],
    PRIMARY KEY(shain_id));
```

この配列型は、機能としてはサポートされたもののそれほど一般的に普及するには至らなかった。
情報は可能な限り分割し、原始的な形でデータを保持することが望ましい。
例）鈴木太郎　 → 　鈴木　太郎

- 情報は可能な限り分割して保存するのがいい。ただし意味を壊してはいけない。

##### ダブルミーニング

特定の列が途中から違う意味になる
（最初は体重で登録していたが、途中から年齢を登録するようになる）

- 列は変数ではない。一度意味を決めたら変更不可。

##### 単一編集テーブル

雑多なコード体系の寄せ集め

例）単一参照テーブルの例

| コードタイプ  | コード値  | コード内容 |
| ------- | ----- | ----- |
| comp_cd | c0001 | A 商事  |
| comp_cd | c0001 | B 化学  |
| comp_cd | c0001 | C 建設  |
| pref_cd | 01    | 北海道   |
| pref_cd | 02    | 青森    |
| pref_cd | 47    | 沖縄    |
| sex_cd  | 1     | 男     |
| sex_cd  | 2     | 女     |

あらゆるタイプのマスタテーブルを、一つのテーブルに放り込んでごった煮にしたもの
なんのコード体系であるかを識別するためにコードの名称が必要になる。
が、「コード内容」という一般化した列名にせざるをえない。

利点：

- マスタテーブルの数が減るため、ER 図やスキーマでシンプルになる
- コード検索の SQL を共通化できる。
  欠点：
- コードタイプ　コード値　コード内容　の各列とも、必要とされる列長はコード体型によって異なるため、余裕を見てかなり大きめの可変超文字列型で宣言する必要がある。
- 一つのテーブルにレコードを集約するため、コード体系の種類と数の多さによってはレコード数が多くなり、検索のパフォーマンスが悪化する。
- コード検索の SQL 内でコードタイプやコード値を間違えて指定してもエラーになることがないため、バグに気づきにくい
- ER 図がすっきりすると言っても、ER モデルとしては正確さを書いており、かえって ER 図の可読性を下げることになる。

テーブルにポリモーフィズムはいらない

##### テーブル分割

一般的にパフォーマンス向上を目的として実施されることが多く、目的がはっきりしていることもあって、
一般にそれほどバッドノウハウとは認識されていない。
実際、テーブル分割の方法には何種類かあり、ものによっては現実的な買いであることもある。
しかし、中には絶対に許されないタイプの方法もあるため、注意する必要がある。

###### 水平分割

レコード単位にテーブルを分割すること。
売上テーブルを水平分割した例

売上テーブル

| 年度   | 会社コード | 売上（億円） |
| ---- | ----- | ------ |
| 2001 | c001  | 44     |
| 2001 | c002  | 43     |
| 2001 | c004  | 46     |
| 2002 | c001  | 52     |
| 2002 | c002  | 55     |
| 2003 | c001  | 46     |
| 2003 | c002  | 32     |
| 2003 | c003  | 56     |

年度売上テーブル(2001)

| 年度   | 会社コード | 売上（億円） |
| ---- | ----- | ------ |
| 2001 | c001  | 44     |
| 2001 | c002  | 43     |
| 2001 | c004  | 46     |

欠点：

- 分割する意味的な理由がない
  このようにテーブルを分割する理由は、正規化の理論からは出てこない。
  パフォーマンスという物理レベルの要請によるもので、逆に言うとその要請がなければ実施する必要がない
- 拡張性に乏しい
  この分割がパフォーマンス改善に効果を発揮するのは、全年度のデータを総なめで検索することはない、という
  前提が成立する場合だけ。
- 他の代替手段がある
  水平分割の手段として、多くの DBMS が「パーティション」と言う機能を持っている。
  パーティション機能を用いることで、テーブルを分割することなく、パーティションキー（「売上」テーブルの場合は「年度」）
  を軸として物理的に格納領域を分離することが可能になる。これによって SQL がアクセスするデータ量を 1/n に減らすことができる。
  パーティション機能は、DBMS によっては持っていなかったり、有料オプションだったりするが、
  利用可能な環境においては水平分割を回避しつつパフォーマンス改善が可能になる。

###### 垂直分割

列単位にテーブルを分割すること。

社員

| 会社コード | 社員 ID | 社員名 | 年齢  | 部署コード |
| ----- | ----- | --- | --- | ----- |
| c001  | 000a  | 加藤  | 40  | d01   |
| c002  | 000b  | 藤本  | 32  | d02   |
| c002  | 001f  | 三島  | 50  | d03   |
| c002  | 009f  | 斉藤  | 47  | d01   |
| c002  | 010a  | 田島  | 25  | d04   |

社員１

| 会社コード | 社員 ID | 年齢  |
| ----- | ----- | --- |
| c001  | 000a  | 40  |
| c002  | 000b  | 32  |
| c002  | 001f  | 50  |
| c002  | 009f  | 47  |
| c002  | 010a  | 25  |

社員２

| 会社コード | 社員 ID | 社員名 | 部署コード |
| ----- | ----- | --- | ----- |
| c001  | 000a  | 加藤  | d01   |
| c002  | 000b  | 藤本  | d02   |
| c002  | 001f  | 三島  | d03   |
| c002  | 009f  | 斉藤  | d01   |
| c002  | 010a  | 田島  | d04   |

この分割は正規化でこそないものの、無損失分解ではあるので、
結合によって元の「社員」テーブルを復元することもできる。
この垂直分割にも、分割することが論理的な意味を持たないと言う水平分割と同様の
欠点があるため、原則利用するべきでない

###### 集約

元のテーブルのデータの一部をサマリ（集計）した結果を、新たなテーブルとして保持するパターン。
テーブルは追加されるだけで元のテーブルの構成が変更されるわけではない。

* 列の絞り込み
上記の垂直分割の例で、会社コード、社員ID、年齢が頻繁に参照される列であるならば、
これらの列だけを持った新しいテーブルを追加作成する。
小規模なテーブルをデータマート（Data Mart）と呼ぶ。元々はDWH分野で使われていた用語。
`データ同期`の問題を抱えてしまう。
オリジナルの社員テーブルは残すため、分割ではない。

* サマリテーブル
列の絞り込みと違うのは、サマリテーブルは集約関数によってレコードを集約して保持する。
テーブルの規模が大きくなると集約処理のコストが大きくなり、実行時間が長くなる。
そこで、事前に集約を行ったテーブルを作っておき、そのテーブルに対する単純なSELECT文で求められるようにする。


##### 不適切なキー
２種類のキー
- 主キー、外部キーなどデータベースの機能で設定されるもの
- テーブルの結合条件で使用される列（結合キー）
この２つの用途で使われる列で使ってはいけないデータ型が可変長文字列（VARCHAR）
固定長文字列は空白による穴埋めをする。一方が固定長文字列で宣言されて、他方のテーブルが可変長文字列
で宣言されていると、単純に列同士を比較するとアンマッチになってしまう。
固定帳文字列の`001`と数値型の`1`は、型変換だけでは不十分で、数値型の方を「０埋め」しなければマッチしない。
こうした厄介無問題にコーディングの時点で頭を悩ませるぐらいなら、最初から
キーには`固定長文字列`の「コード」列が望ましい。

##### ダブルマスタ
同じ役割を果たすはずのマスタテーブルが２つ存在するようなケース。

顧客マスタA

| 顧客コード | 顧客名  |
| ----- | ---- |
| C001  | 山田太郎 |
| C002  | 中島敬人 |
| C003  | 進藤圭太 |

顧客マスタB

| 顧客コード | 顧客名  |
| ----- | ---- |
| C001  | 山田太郎 |
| C002  | 中島敬人 |
| C003  | 進藤圭太 |


AとBは同じ子役の情報も重複して持っているが、片方のマスタにしかない顧客の情報もある。

ダブルマスタは、実際、普通に設計をしている限り、このような状態には陥らない。
ダブルマスタが生じる直接的な理由は一つで、元々別のシステムで利用されていたマスタ同士が、
システム統合によって同じドメインに存在するようになった場合。

