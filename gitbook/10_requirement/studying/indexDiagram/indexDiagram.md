<!-- TOC -->

- [インデックス設計indexDesign](#インデックス設計indexDesign)
- [B-treeインデックス](#B-treeインデックス)
- [カーディナリティの注意点](#カーディナリティの注意点)
- [Bインデックスを利用できていないケース](#インデックスを利用できていないケース)
- [統計情報とoptimizer](#統計情報とoptimizer)

<!-- /TOC -->

#### インデックス設計indexDesign
- アプリケーションのコードに影響を与えない（アプリケーション透過的）
- テーブルのデータに影響を与えない（データ透過的）
- 性能改善の効果が大きい

##### アプリケーション透過的
インデックスを使うかどうかは、DBMSが自動的に判断する。
インデックスを使う場合、単純にデータベース側にインデックスを作成すればいいだけで、
アプリケーションプログラムの変更が不必要。

#### B-treeインデックス
頻繁に利用するインデックスは１種類のみ
B-treeインデックス

##### B-treeインデックスの特徴
- 均一性
    - 平衡木（balanced tree）
- 持続性
    - データ量が多いほどBtreeはフルスキャンより有利
- 処理汎用性
    - 非等値性　不等号やbetweenといった反映検索の条件に対しても高速化
    - 親ソート性

##### B-treeインデックスの設計方針
- 指針１大規模なテーブルに対して作成する
- 指針２カーディなりティの高い列に作成する
- 指針３SQL文でWHERE句の選択条件、または結合条件に使用されている列に作成する

フルスキャンの方が高速な領域がある<br>
目安としてはレコード数が１万件以下の場合ほぼ効果がないと考えて構わない。

#### カーディナリティの注意点
複合列に対してインデックスを作成する場合、カーディなりティは対象の
複合列の組み合わせで考える。
（a,b,c）という列にインデックスを作成するとして、カーディなりティが
それぞれ　a２、ｂ１０、c５　だとする。
この場合、どの一列をとっても、絞り込みの率は５％より大きくなる。
* カーディナリティが高い列ほどインデックスの効果が高い。ただし、値が平均的に分散しているのがベスト。

#### インデックスを利用できていないケース
- インデックス列に演算を行っている
    - WHERE col_1*1.1 > 100;
- 索引列に対してSQL関数を適用している　
    - WHERE SUBSTR(col_1,1,1)='a';
- IS NULL述語を使っている
- 否定形を用いている
- ORを用いている
- 後方一致、または中間一致のLIKE述語を用いている
- 暗黙の型変換を行なっている


#### 統計情報とoptimizer
統計情報はテーブルやインデックスなど「データ」についてのでーた、
すなわち「メタデータ」である。
DBMSはこのメタデータを頼りにSQLのアクセスパスを決定する。

DBMS内の「パーサ（parser）」と呼ばれるモジュール。
SQLが適法な構文であるかチェックする。

パーサによるチェックがすむと、オプティマイザ（optimizer）というモジュールへ送られる。

オプティマイザが実行計画を立てる際、カタログマネージャ　というモジュールに統計情報の照会をかける。
カタログマネージャは、統計情報を管理するモジュールで、図書館のような役割

統計情報を収集すべきタイミングは
`データが大きく更新された後、なるべく早く`
統計情報収集は原則、夜間帯に実施する。


